#pragma once

#include "bakelite.h"

% if not unpacked
// Platform check for packed struct support (unaligned access required)
#if defined(__AVR__) || (defined(__ARM_ARCH) && __ARM_ARCH >= 7) || \
    defined(__x86_64__) || defined(__i386__) || defined(_M_X64) || defined(_M_IX86)
  #define BAKELITE_UNALIGNED_OK 1
#else
  #define BAKELITE_UNALIGNED_OK 0
#endif

static_assert(BAKELITE_UNALIGNED_OK,
  "This code requires unaligned memory access. Regenerate with --unpacked for "
  "Cortex-M0, RISC-V, ESP32, PIC32, or other platforms without unaligned access support.");
% endif

% for enum in enums
% if enum.comment
// {{ enum.comment }}
% endif
enum class {{ enum.name }}: {{map_type(enum.type)}} {
  % for value in enum.values:
  % if value.comment
  // {{ value.comment }}
  % endif
  {{ value.name }} = {{ value.value }},
  % endfor
};
{{""}}
{{""}}
% endfor

% for struct in structs
% if struct.comment
// {{ struct.comment }}
% endif
% if unpacked
struct {{ struct.name }} {
% else
struct __attribute__((packed)) {{ struct.name }} {
% endif
  % for member in struct.members:
  % if member.comment
  // {{ member.comment }}
  % endif
  {{map_type_member(member)}} {{ member.name }}{{-array_postfix(member)-}}{{-size_postfix(member)-}} {{- ' = ' + member.value if member.value -}};
  % endfor
  {{""}}
  template<class T>
  int pack(T &stream) const {
    int rcode = 0;
    % for member in struct.members:
    rcode = {{write_type(member)}}
    if(rcode != 0)
      return rcode;
    % endfor
    return rcode;
  }
  {{""}}
  template<class T>
  int unpack(T &stream) {
    int rcode = 0;
    % for member in struct.members:
    rcode = {{read_type(member)}}
    if(rcode != 0)
      return rcode;
    % endfor
    return rcode;
  }
};
{{""}}
{{""}}

% endfor

% if proto
template <class F = {{framer}}>
class ProtocolBase {
public:
  using ReadFn  = int (*)();
  using WriteFn = size_t (*)(const char *data, size_t length);

  enum class Message {
    NoMessage = -1,
    % for id in message_ids:
    {{id[0]}} = {{id[1]}},
    % endfor
  };

  ProtocolBase(ReadFn read, WriteFn write): m_readFn(read), m_writeFn(write) {}

  Message poll() {
    int byte = (*m_readFn)();
    if(byte < 0) {
      return Message::NoMessage;
    }

    auto result = m_framer.readFrameByte((char)byte);
    if(result.status == Bakelite::CobsDecodeState::Decoded) {
      if(result.length == 0) {
        return Message::NoMessage;
      }

      m_receivedMessage = (Message)result.data[0];
      m_receivedFrameLength = result.length - 1;
      return m_receivedMessage;
    }

    return Message::NoMessage;
  }

% if not unpacked
  // Zero-copy message access - returns reference to message in buffer
  template<typename T>
  T& message() {
    return *reinterpret_cast<T*>(m_framer.buffer() + 1);
  }

  template<typename T>
  const T& message() const {
    return *reinterpret_cast<const T*>(m_framer.buffer() + 1);
  }

  // Zero-copy send overloads for each message type
  % for msg in message_ids:
  int send(const {{msg[0]}}*) {
    m_framer.buffer()[0] = static_cast<char>(Message::{{msg[0]}});
    size_t frameSize = sizeof({{msg[0]}}) + 1;
    auto result = m_framer.encodeFrame(frameSize);

    if(result.status != 0) {
      return result.status;
    }

    size_t ret = (*m_writeFn)(result.data, result.length);
    return ret == result.length ? 0 : -1;
  }
  {{""}}
  % endfor
  // Zero-copy send helper - use as: send<MsgType>()
  template<typename T>
  int send() {
    return send(static_cast<const T*>(nullptr));
  }
% endif

  // Copy-based send (works with variable-length fields, compatible with both modes)
  % for msg in message_ids:
  int send(const {{msg[0]}} &val) {
    Bakelite::BufferStream outStream(m_framer.buffer() + 1, m_framer.bufferSize() - 1);
    m_framer.buffer()[0] = static_cast<char>(Message::{{msg[0]}});
    size_t startPos = outStream.pos();
    val.pack(outStream);
    size_t frameSize = (outStream.pos() - startPos) + 1;
    auto result = m_framer.encodeFrame(frameSize);

    if(result.status != 0) {
      return result.status;
    }

    size_t ret = (*m_writeFn)(result.data, result.length);
    return ret == result.length ? 0 : -1;
  }
  {{""}}
  % endfor

  // Copy-based decode (works with variable-length fields, compatible with both modes)
  % for msg in message_ids:
  int decode({{msg[0]}} &val, char *buffer = nullptr, size_t length = 0) {
    if(m_receivedMessage != Message::{{msg[0]}}) {
      return -1;
    }
    Bakelite::BufferStream stream(
      m_framer.buffer() + 1, m_receivedFrameLength,
      buffer, length
    );
    return val.unpack(stream);
  }
  {{""}}
  % endfor

private:
  ReadFn m_readFn;
  WriteFn m_writeFn;
  F m_framer;

  size_t m_receivedFrameLength = 0;
  Message m_receivedMessage = Message::NoMessage;
};

using Protocol = ProtocolBase<>;
{{""}}
{{""}}
% endif

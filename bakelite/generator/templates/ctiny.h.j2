#ifndef PROTOCOL_H
#define PROTOCOL_H

#include "bakelite.h"

% if not unpacked
/* Platform check for packed struct support (unaligned access required) */
#if defined(__AVR__) || (defined(__ARM_ARCH) && __ARM_ARCH >= 7) || \
    defined(__x86_64__) || defined(__i386__) || defined(_M_X64) || defined(_M_IX86)
  #define BAKELITE_UNALIGNED_OK 1
#else
  #define BAKELITE_UNALIGNED_OK 0
#endif

BAKELITE_STATIC_ASSERT(BAKELITE_UNALIGNED_OK, platform_requires_unpacked_mode);
% endif

/* Forward declarations */
% for struct in structs
struct {{ struct.name }};
% endfor

/* Enums */
% for enum in enums
% if enum.comment
/* {{ enum.comment }} */
% endif
typedef enum {
  % for value in enum.values:
  % if value.comment
  /* {{ value.comment }} */
  % endif
  {{ enum.name }}_{{ value.name }} = {{ value.value }},
  % endfor
} {{ enum.name }};
{{""}}
% endfor

/* Structs */
% for struct in structs
% if struct.comment
/* {{ struct.comment }} */
% endif
% if unpacked
typedef struct {
% else
typedef struct BAKELITE_PACKED {
% endif
  % for member in struct.members:
  % if member.comment
  /* {{ member.comment }} */
  % endif
  {{map_type_member(member)}} {{ member.name }}{{-array_postfix(member)-}}{{-size_postfix(member)-}};
  % endfor
} {{ struct.name }};
{{""}}
static inline int {{ struct.name }}_pack(const {{ struct.name }} *self, Bakelite_Buffer *buf) {
  int rcode = 0;
  % for member in struct.members:
  if ((rcode = {{write_type(member)}}) != 0) return rcode;
  % endfor
  return rcode;
}
{{""}}
static inline int {{ struct.name }}_unpack({{ struct.name }} *self, Bakelite_Buffer *buf) {
  int rcode = 0;
  % for member in struct.members:
  if ((rcode = {{read_type(member)}}) != 0) return rcode;
  % endfor
  return rcode;
}
{{""}}
% endfor

% if proto
/* Protocol message IDs */
typedef enum {
  Protocol_NoMessage = -1,
  % for msg in message_ids:
  Protocol_{{ msg[0] }} = {{ msg[1] }},
  % endfor
} Protocol_Message;

/* Protocol buffer sizes */
#define PROTOCOL_MAX_MESSAGE_SIZE {{ max_length }}
#define PROTOCOL_CRC_SIZE {{ crc_size }}
#define PROTOCOL_BUFFER_SIZE BAKELITE_FRAMER_BUFFER_SIZE(PROTOCOL_MAX_MESSAGE_SIZE, PROTOCOL_CRC_SIZE)
#define PROTOCOL_MESSAGE_OFFSET BAKELITE_FRAMER_MESSAGE_OFFSET(PROTOCOL_MAX_MESSAGE_SIZE, PROTOCOL_CRC_SIZE)

/* Protocol handler */
typedef struct {
  int (*read_byte)(void);
  size_t (*write)(const uint8_t *data, size_t length);
  Bakelite_CobsFramer framer;
  uint8_t buffer[PROTOCOL_BUFFER_SIZE];
  Protocol_Message received_message;
  size_t received_frame_length;
} Protocol;

static inline void Protocol_init(Protocol *self,
                                  int (*read_byte)(void),
                                  size_t (*write)(const uint8_t *data, size_t length)) {
  self->read_byte = read_byte;
  self->write = write;
  self->received_message = Protocol_NoMessage;
  self->received_frame_length = 0;
  bakelite_framer_init(&self->framer, self->buffer, PROTOCOL_BUFFER_SIZE,
                       PROTOCOL_MAX_MESSAGE_SIZE, {{ crc_type }});
}

static inline Protocol_Message Protocol_poll(Protocol *self) {
  int byte = self->read_byte();
  if (byte < 0) {
    return Protocol_NoMessage;
  }

  Bakelite_DecodeResult result = bakelite_framer_read_byte(&self->framer, (uint8_t)byte);
  if (result.status == BAKELITE_DECODE_OK) {
    if (result.length == 0) {
      return Protocol_NoMessage;
    }

    self->received_message = (Protocol_Message)result.data[0];
    self->received_frame_length = result.length - 1;
    return self->received_message;
  }

  return Protocol_NoMessage;
}

/* Get pointer to message data in buffer (for zero-copy access) */
static inline uint8_t *Protocol_buffer(Protocol *self) {
  return bakelite_framer_buffer(&self->framer) + 1;
}

% if not unpacked
/* Zero-copy message access (packed mode only) */
% for msg in message_ids:
static inline {{ msg[0] }} *Protocol_message_{{ msg[0] }}(Protocol *self) {
  return ({{ msg[0] }} *)(bakelite_framer_buffer(&self->framer) + 1);
}
{{""}}
% endfor

/* Zero-copy send functions (packed mode only) */
% for msg in message_ids:
static inline int Protocol_send_zerocopy_{{ msg[0] }}(Protocol *self) {
  bakelite_framer_buffer(&self->framer)[0] = (uint8_t)Protocol_{{ msg[0] }};
  size_t frame_size = sizeof({{ msg[0] }}) + 1;
  Bakelite_FramerResult result = bakelite_framer_encode(&self->framer, frame_size);

  if (result.status != 0) {
    return result.status;
  }

  size_t ret = self->write(result.data, result.length);
  return (ret == result.length) ? 0 : -1;
}
{{""}}
% endfor
% endif

/* Copy-based send functions */
% for msg in message_ids:
static inline int Protocol_send_{{ msg[0] }}(Protocol *self, const {{ msg[0] }} *msg) {
  uint8_t *msg_buf = bakelite_framer_buffer(&self->framer);
  msg_buf[0] = (uint8_t)Protocol_{{ msg[0] }};

  Bakelite_Buffer buf;
  bakelite_buffer_init(&buf, msg_buf + 1, bakelite_framer_buffer_size(&self->framer) - 1);
  {{ msg[0] }}_pack(msg, &buf);

  size_t frame_size = bakelite_buffer_pos(&buf) + 1;
  Bakelite_FramerResult result = bakelite_framer_encode(&self->framer, frame_size);

  if (result.status != 0) {
    return result.status;
  }

  size_t ret = self->write(result.data, result.length);
  return (ret == result.length) ? 0 : -1;
}
{{""}}
% endfor

/* Copy-based decode functions */
% for msg in message_ids:
static inline int Protocol_decode_{{ msg[0] }}(Protocol *self, {{ msg[0] }} *msg,
                                                uint8_t *heap, size_t heap_size) {
  if (self->received_message != Protocol_{{ msg[0] }}) {
    return -1;
  }

  Bakelite_Buffer buf;
  bakelite_buffer_init_with_heap(&buf,
    bakelite_framer_buffer(&self->framer) + 1, self->received_frame_length,
    heap, heap_size);
  return {{ msg[0] }}_unpack(msg, &buf);
}
{{""}}
% endfor
% endif

#endif /* PROTOCOL_H */

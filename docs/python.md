# Python
The Python API is designed to be simple to use.
It requires Python 3.13+.
It is not currently compatible with MicroPython.

## Code Generation

Generate the runtime library and protocol code:
```sh
bakelite runtime -l python           # Creates bakelite_runtime/ folder
bakelite gen -l python -i proto.bakelite -o proto.py
```

## Example (Sync)

```python
from proto import Protocol, TestMessage, Ack
import serial

with serial.Serial("/dev/ttyusb0", 9600) as port:
    proto = Protocol(stream=port)
    proto.send(TestMessage(status=True, message="Ping!"))

    for msg in proto.messages():
        if isinstance(msg, Ack):
            print(f"Ack code={msg.code}")
```

## Example (Async)

```python
import asyncio
from proto import Protocol, TestMessage, Ack

async def main():
    reader, writer = await asyncio.open_connection('localhost', 8888)
    proto = Protocol(stream=(reader, writer))

    await proto.send(TestMessage(status=True, message="Ping!"), async_=True)

    async for msg in proto.messages(async_=True):
        if isinstance(msg, Ack):
            print(f"Ack code={msg.code}")

asyncio.run(main())
```

### String Handling
In Python 3, strings are Unicode by default.
You'll need to encode the string as bytes before sending a message and decode them after receiving a message.

For example:
```python
# send a message
msg TestMessage(
  text: "This is a test string".encode('utf-8') # encode the string as utf-8
)
proto.send(msg)

# receive a message
msg = proto.poll()
print(msg.text.decode('utf-8'))
```

Any encoding that doesn't add null characters will work.
The two most common encoding types are `utf-8` and `ascii`.
If you're working with an embedded device that doesn't have native Unicode support, `ascii` is recommended.
If you need to send `utf-16` encoded text, use a bytes[] type instead.

## API
### Protocol
The Protocol class is generated by bakelite if you have a `protocol` section in your protocol definition.
Pass a stream-like object to the constructor:
- For sync: `BufferedIOBase` (serial port, TCP socket, etc.)
- For async: `tuple[StreamReader, StreamWriter]`

##### \_\_init\_\_(self, stream)
__arguments:__

* __stream__ - `BufferedIOBase` for sync, or `(StreamReader, StreamWriter)` for async.

##### messages(self, async_=False) -> Iterator | AsyncIterator
The primary interface for consuming messages. Returns an iterator that yields messages as they arrive.

```python
# Sync
for msg in proto.messages():
    handle(msg)

# Async
async for msg in proto.messages(async_=True):
    await handle(msg)
```

##### send(self, message, async_=False) -> None | Coroutine
Sends a message. The message is serialized, encoded as a frame, and sent to the stream.

__arguments:__

* __message__ - Any struct with an assigned message-id.
* __async___ - If True, returns a coroutine for async sending.

##### poll(self, async_=False) -> Struct | None | Coroutine
Reads available data and returns a message if one is complete, otherwise None.

__arguments:__

* __async___ - If True, returns a coroutine for async polling.

### Struct
A struct class is generated for each struct in your protocol definition.
Structs are dataclasses where each field in the struct becomes a member of the class.

For example, this struct definition:
```proto
struct TestMessage {
  text: string[]
  code: uint8
}
```

is equivalent to:
```python
@dataclass
class TestMessage:
  text: str
  code: int

  pack(self, stream) -> None:
    ...
  
  unpack(stream) -> TestMessage:
    ...
```

The `pack()` and `unpack()` function are provided for serialization.

##### pack(self, stream: BufferedIOBase) -> None
Serialize the struct and write it to the stream.

__arguments:__

* __stream__ - Any stream like object that implements `read()` and `write()` functions.

##### unpack(stream: BufferedIOBase) -> Struct
Deserialize a struct from the stream.
`unpack()` is a static method which returns an instance of the struct.

__example:__
```python
msg = TestMessage.unpack(stream)
print(msg.text)
```

__arguments:__

* __stream__ - Any stream like object that implements `read()` and `write()` functions.

__returns:__<br/>
An instance of the struct class.


### Enum
An enum class is generated for each enum in your protocol definition.
Enums map to python's [enum class](https://docs.python.org/3/library/enum.html).

For example:
```proto
enum MyColor: uint8 {
  Red = 1
  Green = 2
  Blue = 3
}
```

Would map to:
```python
class MyColor(enum):
  Red = 1
  Green = 2
  Blue = 3

  pack(self, stream) -> None:
    ...
  
  unpack(stream) -> MyColor:
    ...
```

##### pack(self, stream: BufferedIOBase) -> None
Serialize the enum and write it to the stream.

__arguments:__

* __stream__ - Any stream like object that implements `read()` and `write()` functions.

##### unpack(stream: BufferedIOBase) -> Struct
Deserialize an enum from the stream.
`unpack()` is a static method which returns an instance of the enum class.

__example:__
```python
color = MyColor.unpack(stream)
print(color)
```

__arguments:__

* __stream__ - Any stream like object that implements `read()` and `write()` functions.

__returns:__<br/>
An instance of the enum class.
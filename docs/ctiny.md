# C (Tiny)
The `ctiny` target generates pure C99 code for embedded systems with highly constrained resources.
It has a small memory footprint and does not allocate on the heap.
It works well on microcontrollers with under 2k of RAM or on a desktop PC.

## Features
  * Header only (C99)
  * Small memory footprint with single-buffer design
  * Zero-copy message access (packed mode)
  * No heap memory allocation
  * No dependencies beyond standard C library

## Example
Code generation:
```sh
bakelite runtime -l ctiny -o bakelite.h  # One-time generation of the library
bakelite gen -l ctiny -i proto.bakelite -o proto.h
```

Use the generated code:
```c
#include "proto.h"

int read_byte(void) {
  // Return one byte or -1 if no data available
}

size_t write_bytes(const uint8_t *data, size_t len) {
  // Write data, return bytes written
}

int main(void) {
  Protocol proto;
  Protocol_init(&proto, read_byte, write_bytes);

  // Zero-copy send - write directly to the buffer
  HelloMsg *msg = Protocol_message_HelloMsg(&proto);
  msg->code = 42;
  strcpy(msg->message, "Hello world!");
  Protocol_send_zerocopy_HelloMsg(&proto);

  // Poll for messages
  while (1) {
    Protocol_Message msg_id = Protocol_poll(&proto);

    switch (msg_id) {
    case Protocol_NoMessage:
      break;

    case Protocol_ReplyMsg: {
      // Zero-copy receive - access message directly in buffer
      ReplyMsg *reply = Protocol_message_ReplyMsg(&proto);
      printf("Reply: %s\n", reply->text);
      break;
    }
    default:
      break;
    }
  }
}
```

## Platform Support
By default, Bakelite generates packed structs that enable zero-copy message access.
This requires platforms that support unaligned memory access.

**Supported platforms (default packed mode):**
- x86/x64 (Intel, AMD)
- ARM Cortex-M3 and higher (ARMv7+)
- AVR (Arduino Uno, Nano, Mega)

**Platforms requiring `--unpacked`:**
- ARM Cortex-M0/M0+ (no unaligned access)
- RISC-V
- ESP32 (Xtensa)
- PIC32

For platforms without unaligned access support, use the `--unpacked` flag:
```sh
bakelite gen -l ctiny -i proto.bakelite -o proto.h --unpacked
```

A compile-time check will fail if packed code is used on an unsupported platform.

## Runtime
The code generated by Bakelite is broken into two parts:
the runtime (`bakelite runtime`) and the protocol implementation (`bakelite gen`).

The runtime contains the library code and only needs to be re-generated when upgrading Bakelite.
The protocol implementation contains the type definitions and serializers from your .bakelite file.

## API

### Type Mappings
|Bakelite Type                 |C Type                                |
|------------------------------|--------------------------------------|
|int8, int16, int32, int64     |int8_t, int16_t, int32_t, int64_t     |
|uint8, uint16, uint32, uint64 |uint8_t, uint16_t, uint32_t, uint64_t |
|float32, float64              |float, double                         |
|bool                          |bool                                  |
|bytes[N]                      |struct { uint8_t data[N]; uint8_t len; } |
|string[N]                     |char[N+1]                             |
|T[N]                          |struct { T data[N]; uint8_t len; }    |
|struct T                      |typedef struct { } T                  |
|enum T: S                     |typedef enum { } T                    |

All `bytes[N]` and `T[N]` types use inline anonymous structs with a `data` array and `len` field.
Strings are null-terminated character arrays with space for N characters plus null terminator.

### Protocol

##### Protocol_init(Protocol *self, ReadFn read, WriteFn write)
Initialize the protocol handler.

**arguments:**
* **read** - Function returning one byte or -1 if no data: `int (*)(void)`
* **write** - Function writing bytes: `size_t (*)(const uint8_t *data, size_t length)`

##### Protocol_poll(Protocol *self) -> Protocol_Message
Reads available data and returns the message ID if a complete frame was received.

**returns:**
The message ID (e.g., `Protocol_MyMsg`) or `Protocol_NoMessage`.

##### Protocol_message_T(Protocol *self) -> T*
Returns a pointer to the message in the internal buffer. Use for zero-copy access.

**For receiving:** Call after `Protocol_poll()` returns a message ID.
**For sending:** Call before `Protocol_send_zerocopy_T()` to write data.

##### Protocol_send_zerocopy_T(Protocol *self) -> int
Sends the message already written to the buffer. Zero-copy.

**returns:** 0 on success.

##### Protocol_send_T(Protocol *self, const T *msg) -> int
Copy-based send. Serializes and sends a message.

**returns:** 0 on success.

##### Protocol_decode_T(Protocol *self, T *msg) -> int
Copy-based decode. Use when you need the data to persist beyond the next `Protocol_poll()`.

**returns:** 0 on success.

### Struct
Each struct generates pack/unpack functions:

```c
int T_pack(const T *self, Bakelite_Buffer *buf);
int T_unpack(T *self, Bakelite_Buffer *buf);
```

# C++ (Tiny)
The `cpptiny` target is designed to be used in embedded systems with highly constrained resources.
It has a small memory footprint and does not allocate on the heap or use the STL.
It works well on microcontrollers with under 2k of RAM or on a desktop PC.
A compiler that can target the `C++14` standard is required.

## Features
  * Header only
  * Small memory footprint with single-buffer design
  * Zero-copy message access (packed mode)
  * No heap memory allocation
  * Does not use the STL
  * Produces well-optimized assembly when compiler optimizations are enabled

## Example
Code generation
```sh
$ bakelite runtime -l cpptiny -o bakelite.h  # One-time generation of the library
$ bakelite gen -l cpptiny -i proto.bakelite -o proto.h
```

Use the generated code to implement a simple protocol.
```c++
#include "proto.h"

int main(int argc, char *arv[]) {
  Serial port("/dev/ttyUSB0", 9600);

  Protocol proto(
    []() { return port.read(); },
    [](const char *data, size_t length) { return port.write(data, length); }
  );

  // Zero-copy send - write directly to the buffer
  auto& msg = proto.message<HelloMsg>();
  msg.code = 42;
  strcpy(msg.message, "Hello world!");
  proto.send<HelloMsg>();

  // Wait for a reply
  while(true) {
    Protocol::Message messageId = proto.poll();

    switch(messageId) {
    case Protocol::Message::NoMessage:
      break;

    case Protocol::Message::ReplyMsg:
      // Zero-copy receive - access message directly in buffer
      const auto& reply = proto.message<ReplyMsg>();
      cout << "Reply: " << reply.text << endl;
      break;
    default:
      break;
    }
  }
}
```

## Platform Support
By default, Bakelite generates packed structs that enable zero-copy message access.
This requires platforms that support unaligned memory access.

**Supported platforms (default packed mode):**
- x86/x64 (Intel, AMD)
- ARM Cortex-M3 and higher (ARMv7+)
- AVR (Arduino Uno, Nano, Mega)

**Platforms requiring `--unpacked`:**
- ARM Cortex-M0/M0+ (no unaligned access)
- RISC-V
- ESP32 (Xtensa)
- PIC32

For platforms without unaligned access support, use the `--unpacked` flag:
```sh
$ bakelite gen -l cpptiny -i proto.bakelite -o proto.h --unpacked
```

A compile-time check will fail if packed code is used on an unsupported platform.

## Runtime
The code generated by Bakelite is broken into two parts.
The runtime, generated with `bakelite runtime`
and the protocol implementation generated with `bakelite gen`.
The protocol implementation contains the type definitions, serializers, and protocol implementation defined in your .proto file.

The runtime contains the library code that supports your protocol implementation.
The runtime does not change and only needs to be re-generated when upgrading Bakelite.
Typically, the runtime is written to a file named `bakelite.h`.

The runtime uses the Bakelite namespace.
The protocol implementation does not use a namespace.

### Memory Overhead
Bakelite uses a single buffer for both sending and receiving, reducing memory usage by approximately 50% compared to dual-buffer implementations.

For a protocol with a maxSize of 256 bytes, COBS framing, and CRC8, the buffer uses approximately 261 bytes (256 data + 2 COBS overhead + 1 CRC + 1 message ID + 1 null terminator).

The total size of the Protocol object on a 64-bit system is approximately 290 bytes. On an AVR system, it's approximately 280 bytes.

If RAM is limited, reduce your maxSize or send smaller messages.

## API
### Type Mappings
|Bakelite Type                 |C++ Type                              |
|------------------------------|--------------------------------------|
|int8, int16, int32, int64     |int8_t, int16_t, int32_t, int64_t     |
|uint8, uint16, uint32, uint64 |uint8_t, uint16_t, uint32_t, uint64_t |
|float32, float64              |float, double                         |
|bool                          |bool                                  |
|bytes[N]                      |Bakelite::SizedArray<uint8_t, N>      |
|string[N]                     |char[N+1]                             |
|T[N]                          |Bakelite::SizedArray<T, N>            |
|struct T                      |struct T {}                           |
|enum T: S                     |enum class T: S {}                    |

All `bytes[N]` and `T[N]` types use `SizedArray`, a fixed-capacity container with runtime length tracking.
Strings are null-terminated character arrays with space for N characters plus null terminator.

### Protocol
The Protocol class is generated by bakelite if you have a `protocol` section in your protocol definition.
The constructor takes two lambdas or C function pointers that user used for reading and writing data.

__example definition:__
```proto
protocol {
  maxLength = 256
  framing = COBS
  crc = CRC8

  messageIds {
    ...
  }
}
```

##### Protocol(ReadFn read, WriteFn write)
__arguments:__

* __read__ - A function with the signature int(). When called, returns one byte, or -1 if no data is available.
* __write__ - A function with the signature int(const char *data, size_t length). When called, write length bytes to the output device. Return the number of bytes written.

##### poll() -> Protocol::MessageId
Reads available data and returns the message ID if a complete frame was received.

__returns:__<br/>
The message ID if available, or `Protocol::MessageId::NoMessage`.

##### message\<T\>() -> T&
Returns a reference to the message in the internal buffer. Use this for zero-copy access.

**For receiving:** Call after `poll()` returns a message ID to access the received data.
**For sending:** Call before `send<T>()` to write data directly to the buffer.

```c++
// Receiving
const auto& msg = proto.message<MyMsg>();

// Sending
auto& msg = proto.message<MyMsg>();
msg.field = value;
proto.send<MyMsg>();
```

##### send\<T\>() -> int
Sends the message already written to the buffer via `message<T>()`. Zero-copy.

__returns:__<br/>
0 on success.

##### send(const Struct &message) -> int
Copy-based send. Serializes and sends a message. Works with variable-length fields.

__arguments:__

* __message__ - Any struct with an assigned message-id.

__returns:__<br/>
0 on success.

##### decode(Struct &message) -> int
Copy-based decode. Use when you need the data to persist beyond the next `poll()`.

__arguments:__

* __message__ - Any struct with an assigned message-id.

__returns:__<br/>
0 on success.

### Struct
A struct is generated for every struct defined in the protocol specification.

For example, this struct definition:
```proto
struct TestMessage {
  text: string[64]
  data: bytes[32]
  numbers: uint16[8]
  code: uint8
}
```

is equivalent to:
```c++
struct TestMessage {
  char text[65];                          // string[64] -> null-terminated
  Bakelite::SizedArray<uint8_t, 32> data; // bytes[32]
  Bakelite::SizedArray<uint16_t, 8> numbers; // uint16[8]
  uint8_t code;

  int pack(BufferStream& stream) { ... }
  int unpack(BufferStream& stream) { ... }
};
```

The `pack()` and `unpack()` function are provided for serialization.

##### pack(stream) -> int
Serialize the struct and write it to the stream.

__arguments:__

* __stream__ - Any stream like object that implements `read()` and `write()` functions.

__returns:__<br/>
0 on success.

##### unpack(stream) -> int
Deserialize a struct from the stream.

__arguments:__

* __stream__ - Any stream like object that implements `read()` and `write()` functions.

__returns:__<br/>
0 on success.


### Enum
An enum class is generated for each enum in your protocol definition.
Unlike the python implementation, Enums do not have their own pack and unpack functions.

For example:
```proto
enum MyColor: uint8 {
  Red = 1
  Green = 2
  Blue = 3
}
```

Would map to:
```c++
enum class MyColor: uint8_t {
  Red = 1
  Green = 2
  Blue = 3
}
```
